```markdown
# Table of Contents

- 1 Introduction ....................................................................................................................... 4  
  - 1.1 Reasons for using assembly code .............................................................................. 5  
  - 1.2 Reasons for not using assembly code ........................................................................ 5  
  - 1.3 Operating systems covered by this manual ................................................................. 6  

- 2 Before you start ................................................................................................................. 7  
  - 2.1 Things to decide before you start programming .......................................................... 7  
  - 2.2 Make a test strategy.................................................................................................... 8  
  - 2.3 Common coding pitfalls ............................................................................................... 9  

- 3 The basics of assembly coding........................................................................................ 11  
  - 3.1 Assemblers available ................................................................................................ 11  
  - 3.2 Register set and basic instructions............................................................................ 14  
  - 3.3 Addressing modes .................................................................................................... 18  
  - 3.4 Instruction code format ............................................................................................. 25  
  - 3.5 Instruction prefixes .................................................................................................... 26  

- 4 ABI standards.................................................................................................................. 27  
  - 4.1 Register usage.......................................................................................................... 28  
  - 4.2 Data storage ............................................................................................................. 28  
  - 4.3 Function calling conventions ..................................................................................... 29  
  - 4.4 Name mangling and name decoration ...................................................................... 31  
  - 4.5 Function examples .................................................................................................... 31  

- 5 Using intrinsic functions in C++ ....................................................................................... 34  
  - 5.1 Using intrinsic functions for system code .................................................................. 35  
  - 5.2 Using intrinsic functions for instructions not available in standard C++ ..................... 36  
  - 5.3 Using intrinsic functions for vector operations ........................................................... 36  
  - 5.4 Availability of intrinsic functions ................................................................................. 36  

- 6 Using inline assembly ...................................................................................................... 36  
  - 6.1 MASM style inline assembly ..................................................................................... 37  
  - 6.2 Gnu style inline assembly ......................................................................................... 42  
  - 6.3 Inline assembly in Delphi Pascal ............................................................................... 45  

- 7 Using an assembler......................................................................................................... 45  
  - 7.1 Static link libraries ..................................................................................................... 46  
  - 7.2 Dynamic link libraries ................................................................................................ 47  
  - 7.3 Libraries in source code form .................................................................................... 48  
  - 7.4 Making classes in assembly...................................................................................... 48  
  - 7.5 Thread-safe functions ............................................................................................... 50  
  - 7.6 Makefiles .................................................................................................................. 51  

- 8 Making function libraries compatible with multiple compilers and platforms ..................... 52  
  - 8.1 Supporting multiple name mangling schemes ........................................................... 52  
  - 8.2 Supporting multiple calling conventions in 32 bit mode ............................................. 53  
  - 8.3 Supporting multiple calling conventions in 64 bit mode ............................................. 56  
  - 8.4 Supporting different object file formats ...................................................................... 58  
  - 8.5 Supporting other high level languages ...................................................................... 59  

- 9 Optimizing for speed ....................................................................................................... 60  
  - 9.1 Identify the most critical parts of your code ............................................................... 60  
  - 9.2 Out of order execution .............................................................................................. 60  
  - 9.3 Instruction fetch, decoding and retirement ................................................................ 63  
  - 9.4 Instruction latency and throughput ............................................................................ 64  
  - 9.5 Break dependency chains ......................................................................................... 64  
  - 9.6 Jumps and calls ........................................................................................................ 66  

- 10 Optimizing for size ......................................................................................................... 73  
  - 10.1 Choosing shorter instructions .................................................................................. 73  
  - 10.2 Using shorter constants and addresses .................................................................. 75  
  - 10.3 Reusing constants .................................................................................................. 76  
  - 10.4 Constants in 64-bit mode ........................................................................................ 76  
  - 10.5 Addresses and pointers in 64-bit mode ................................................................... 77  
  - 10.6 Making instructions longer for the sake of alignment ............................................... 79  
  - 10.7 Using multi-byte NOPs for alignment ...................................................................... 81  

- 11 Optimizing memory access............................................................................................ 81  
  - 11.1 How caching works ................................................................................................. 82  
  - 11.2 Trace cache ............................................................................................................ 83  
  - 11.3 µop cache ............................................................................................................... 83  
  - 11.4 Alignment of data .................................................................................................... 83  
  - 11.5 Alignment of code ................................................................................................... 86  
  - 11.6 Organizing data for improved caching ..................................................................... 87  
  - 11.7 Organizing code for improved caching .................................................................... 88  
  - 11.8 Cache control instructions ....................................................................................... 88  

- 12 Loops ............................................................................................................................ 88  
  - 12.1 Minimize loop overhead .......................................................................................... 88  
  - 12.2 Induction variables .................................................................................................. 91  
  - 12.3 Move loop-invariant code ........................................................................................ 92  
  - 12.4 Find the bottlenecks ................................................................................................ 92  
  - 12.5 Instruction fetch, decoding and retirement in a loop ................................................ 93  
  - 12.6 Distribute µops evenly between execution units ...................................................... 94  
  - 12.7 An example of analysis for bottlenecks in vector loops ........................................... 94  
  - 12.8 Same example on Core2 ........................................................................................ 98  
  - 12.9 Same example on Sandy Bridge ............................................................................. 99  
  - 12.10 Same example with FMA4 .................................................................................. 100  
  - 12.11 Same example with FMA3 .................................................................................. 100  
  - 12.12 Loop unrolling ..................................................................................................... 101  
  - 12.13 Vector loops using mask registers (AVX512) ...................................................... 103  
  - 12.14 Optimize caching ................................................................................................ 105  
  - 12.15 Parallelization ..................................................................................................... 106  
  - 12.16 Analyzing dependences ...................................................................................... 107  
  - 12.17 Loops on processors without out-of-order execution ........................................... 112  
  - 12.18 Macro loops ........................................................................................................ 113  

- 13 Vector programming .................................................................................................... 115  
  - 13.1 Using AVX instruction set and YMM or ZMM registers .......................................... 117  
  - 13.2 Mixing VEX and SSE code.................................................................................... 117  
  - 13.3 Using AVX512 instruction set and ZMM registers ................................................. 122  
  - 13.4 Conditional moves in xmm and ymm registers ...................................................... 123  
  - 13.5 Conditional moves with AVX512 ........................................................................... 126  
  - 13.6 Using vector instructions with other types of data than they are intended for ........ 128  
  - 13.7 Permuting data ..................................................................................................... 130  
  - 13.8 Generating constants ............................................................................................ 133  
  - 13.9 Accessing unaligned data and partial vectors ....................................................... 135  
  - 13.10 Vector operations in general purpose registers ................................................... 140  

- 14 Multithreading .............................................................................................................. 142  
  - 14.1 Simultaneous multithreading ................................................................................. 142  

- 15 CPU dispatching.......................................................................................................... 143  
  - 15.1 Checking for operating system support for XMM, YMM, and ZMM registers ......... 144  

- 16 Problematic Instructions .............................................................................................. 145  
  - 16.1 LEA instruction (all processors)............................................................................. 145  
  - 16.2 INC and DEC ........................................................................................................ 146  
  - 16.3 XCHG (all processors) .......................................................................................... 146  
  - 16.4 Shifts and rotates (P4) .......................................................................................... 147  
  - 16.5 Rotates through carry (all processors) .................................................................. 147  
  - 16.6 Bit test (all processors) ......................................................................................... 147  
  - 16.7 LAHF and SAHF (all processors) .......................................................................... 147  
  - 16.8 Integer multiplication (all processors) .................................................................... 147  
  - 16.9 Division (all processors) ........................................................................................ 147  
  - 16.10 String instructions (all processors) ...................................................................... 151  
  - 16.11 Vectorized string instructions (processors with SSE4.2)...................................... 151  
  - 16.12 WAIT instruction (all processors) ........................................................................ 152  
  - 16.13 FCOM + FSTSW AX (all processors) .................................................................. 153  
  - 16.14 FPREM (all processors) ...................................................................................... 154  
  - 16.15 FRNDINT (all processors) ................................................................................... 154  
  - 16.16 FSCALE and exponential function (all processors) ............................................. 154  
  - 16.17 FPTAN (all processors) ....................................................................................... 155  
  - 16.18 FSQRT (SSE processors) ................................................................................... 156  
  - 16.19 FLDCW (Most Intel processors) .......................................................................... 156  
  - 16.20 MASKMOV instructions....................................................................................... 156  

- 17 Special topics .............................................................................................................. 157  
  - 17.1 XMM versus floating point registers ...................................................................... 157  
  - 17.2 MMX versus XMM registers .................................................................................. 158  
  - 17.3 XMM versus YMM and ZMM registers .................................................................. 158  
  - 17.4 Freeing floating point registers (all processors) ..................................................... 158  
  - 17.5 Transitions between floating point and MMX instructions ...................................... 159  
  - 17.6 Converting from floating point to integer (All processors) ...................................... 159  
  - 17.7 Using integer instructions for floating point operations .......................................... 160  
  - 17.8 Using floating point instructions for integer operations .......................................... 163  
  - 17.9 Moving blocks of data (All processors) .................................................................. 164  
  - 17.10 Self-modifying code (All processors) ................................................................... 166  

- 18 Measuring performance............................................................................................... 167  
  - 18.1 Testing speed ....................................................................................................... 167  
  - 18.2 The pitfalls of unit-testing ...................................................................................... 168  

- 19 Literature ..................................................................................................................... 169  
- 20 Copyright notice .......................................................................................................... 169  
```
