- **Addressing Modes** — Methods for specifying the address of an object accessed by an instruction, including register, immediate, displacement, register indirect, indexed, direct, memory indirect, autoincrement, autodecrement, and scaled modes.

- **Accumulator Architecture** — An instruction set architecture where one operand is implicitly the accumulator register; instructions typically involve this implicit operand and another explicit operand.

- **ALU (Arithmetic Logic Unit) Instruction** — Instructions that perform arithmetic or logical operations, can have two or three operands, with variations in whether memory operands are allowed.

- **Branch (Conditional Branch)** — A control instruction that changes program flow based on a specified condition.

- **Call/Return** — Control transfer instructions for invoking and returning from procedures or functions.

- **Code Density** — Measure of the size of compiled code; architectures with lower instruction counts and shorter instructions tend to have better code density.

- **Compiler** — A program that translates high-level language code into machine instructions, applying various optimizations and transformations.

- **Condition Register (Condition Codes)** — Special bits set by ALU operations used to control branches; can introduce dependencies and complexity.

- **Displacement Addressing Mode** — An addressing mode where the effective address is the sum of a base register and a constant displacement.

- **Floating Point Operations** — Instructions performing arithmetic on floating-point data types, generally supporting single and double precision per IEEE 754 standard.

- **Graph Coloring (Register Allocation)** — Compiler technique to assign variables to registers efficiently by representing conflicts as a graph coloring problem.

- **Immediate Addressing Mode** — An addressing mode specifying a constant operand encoded directly in the instruction.

- **Load-Store Architecture** — A general-purpose register architecture where only load and store instructions access memory; ALU operations only use registers.

- **Memory-Memory Architecture** — An architecture where instructions can have operands directly in memory; rare in modern computers.

- **PC-Relative Addressing** — A mode where the instruction’s target address is specified relative to the current program counter, enabling position-independent code.

- **Procedure Call Conventions** — Strategies for saving registers and passing parameters, either by caller saving or callee saving.

- **Register-Indirect Addressing Mode** — An addressing mode where the effective address is the contents of a register.

- **Register-Memory Architecture** — An architecture allowing memory access as part of arithmetic instructions, typically with fewer registers.

- **Stack Architecture** — An architecture using a stack for all or most arithmetic operations, with operands implicitly on the stack top.

- **SIMD (Single Instruction Multiple Data)** — Instruction set extensions supporting parallel operations on multiple data elements, used in multimedia and vector processing.

- **Special-Purpose Registers** — Registers designated for particular uses, reducing the effective number of general-purpose registers.

- **Three-Operand Instruction Format** — Instructions with two source operands and one destination operand, typical of modern load-store architectures.

- **Two-Operand Instruction Format** — Instructions where one operand is both a source and destination.

- **Variable-Length Encoding** — An instruction encoding scheme allowing different length instructions, enabling more compact code but complex decoding.

- **Zero Register (R0 in MIPS)** — A register hardwired to zero, used to simplify instruction formats and operations.
