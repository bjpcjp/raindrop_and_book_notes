1. **Q:** What are the three classes of pipeline hazards, and how does each typically affect the execution of instructions in a pipelined RISC processor?
   **A:** The three pipeline hazards are: 
   - Structural hazards, which occur due to resource conflicts preventing simultaneous use of hardware units, often causing pipeline stalls.
   - Data hazards, which happen when an instruction depends on the results of a previous instruction not yet written back, potentially requiring stalls or forwarding.
   - Control hazards, arising from branching instructions that may change the program counter and cause incorrect instruction fetches, typically handled by stalls, branch prediction, or delay slots.
   Each hazard can introduce stalls or bubbles, reducing ideal pipeline throughput.
   **External example:** The classic MIPS pipeline uses forwarding and stalling to manage data hazards and employs branch prediction to reduce control hazards (Hennessy & Patterson, Computer Organization & Design: https://csapp.cs.cmu.edu/public/waside/Chapter3_Sections.pdf).

2. **Q:** Explain the role of pipeline registers in the classic five-stage RISC pipeline and why they are essential for correct pipelined execution.
   **A:** Pipeline registers separate the stages of the pipeline by holding intermediate results and control data between stages at each clock cycle’s edge. They prevent interference between instructions in adjacent stages by preserving state and ensuring data from one instruction does not overwrite or merge with data of another. These edge-triggered registers enable simultaneous and overlapped instruction execution, making pipelining feasible.
   **External example:** Pipeline registers are fundamental to pipelined processors, as shown in the MIPS architecture design, enabling multiple overlapping instruction executions (MIPS Pipeline Registers Explainer, Patterson & Hennessy: https://www.cs.cmu.edu/afs/cs/academic/class/15213-f07/www/pipeline.pdf).

3. **Q:** How does forwarding (bypassing) mitigate data hazards in pipelined execution, and why are some load-use hazards still unavoidable without stalls?
   **A:** Forwarding feeds the ALU or memory inputs directly from pipeline registers that hold results not yet written back, bypassing the register file and allowing dependent instructions to use produced values earlier. However, load-use hazards occur because the loaded data is only available at the end of the MEM stage, while the dependent instruction requires it at the EX stage—making forwarding insufficient and necessitating pipeline stalls to wait for valid data.
   **External example:** Forwarding and stalls are standard hazard mitigation techniques in MIPS pipelines, described in the MIPS architecture reference and widely used in pipelined microprocessors (MIPS R2000 Pipeline Data Hazard Tutorial, UC Berkeley: https://inst.eecs.berkeley.edu/~cs61c/fa18/materials/handout-pipeline3.pdf).

4. **Q:** Describe the difference between structural and control hazards, including an example of each and their typical resolution strategies.
   **A:** Structural hazards occur due to hardware resource conflicts, such as a single memory port shared by instruction fetch and data memory causing pipeline stalls. Control hazards result from conditional branches that affect the program counter, leading to uncertain instruction fetches. Structural hazards are usually resolved by resource duplication or stalling, whereas control hazards are managed via pipeline stalls, static or dynamic branch prediction, or delayed branching.
   **External example:** Structural hazard examples include the single-ported memory in early MIPS machines causing stalls; control hazards are addressed by static branch prediction or dynamic branch predictors in modern CPUs (Computer Architecture: A Quantitative Approach, Hennessy & Patterson: https://cacm.acm.org/magazines/2017/10/220216-the-truth-about-prediction/fulltext).

5. **Q:** What are the main types of exceptions in a pipelined processor, what properties make some exceptions harder to handle, and how does pipelining complicate exception handling?
   **A:** Exceptions include synchronous (predictable) and asynchronous events such as I/O requests, arithmetic overflow, page faults, and hardware malfunctions. Exceptions that occur within instructions and must be precisely restartable are the hardest to handle because partial instruction execution state must be saved/restored. Pipelining complicates exception handling by overlapping multiple instructions, requiring mechanisms to track, order, mask writes from faulting instructions, and maintain precise state to support restartability.
   **External example:** Precise exception handling in pipelined processors is elaborated in the MIPS architecture, enabling virtual memory and reliable interrupt handling (MIPS Interrupt and Exception Handling: https://www.ece.uc.edu/~omearac/Sim/pbls/MIPS_pipe3.pdf).

6. **Q:** Explain how branch prediction schemes improve pipeline performance, comparing static and dynamic approaches with respect to branch penalty reduction.
   **A:** Static schemes rely on compile-time decisions or profiling to predict branches, treating them as always taken or untaken, potentially incurring significant penalty if mispredicted. Dynamic schemes use hardware predictors like 1-bit or 2-bit saturating counters in branch-prediction buffers to learn branch behavior at runtime, substantially reducing misprediction rates and hence stalls. Accurate prediction reduces branch penalties and improves CPI, critical in deeper pipelines with longer branch delays.
   **External example:** Intel processors use dynamic branch predictors that significantly reduce pipeline stalls caused by branches (Intel 64 and IA-32 Architectures Optimization Reference Manual: https://www.intel.com/content/www/us/en/develop/documentation/optimization-manual.html).

7. **Q:** In implementing a pipelined MIPS processor, what control signals and multiplexers must be managed at different pipeline stages to correctly handle various instruction types and hazards?
   **A:** Control signals must set ALU operation each cycle, select ALU inputs (registers or immediate), choose PC source (sequential or branch target), and select register destination fields for write-back depending on the instruction type. Multiplexers select between inputs for the ALU, PC update, and register write-back source (ALU output or memory data). Hazard detection controls stall insertion and forwarding multiplexers to resolve hazards dynamically during instruction decode and execute stages.
   **External example:** The MIPS datapath design with control signals and multiplexers is well documented in "Computer Organization and Design" by Patterson and Hennessy (https://csapp.cs.cmu.edu/public/waside/waside-ch3.pdf).

8. **Q:** Why does pipelining not reduce the execution time of individual instructions, and how does this impact the attainable speedup in a pipelined CPU?
   **A:** Pipelining overlaps the execution of multiple instructions by dividing instruction execution into stages, but each individual instruction still passes sequentially through all stages, so its latency remains the same or slightly increases due to overhead. Hence, speedup arises from increased throughput (number of instructions completed per unit time) rather than reduced per-instruction latency, limiting speedup by pipeline depth minus stalls and overhead.
   **External example:** The classic analogy of pipelining as an assembly line emphasizes throughput improvement over individual task time reduction (Hennessy & Patterson, Computer Architecture: https://calhoun.nps.edu/bitstream/handle/10945/52951/Pipeline.pdf).

9. **Q:** How do delayed branches operate in a pipelined processor, and what are the compiler’s responsibilities for correctly scheduling delay slot instructions?
   **A:** Delayed branches execute the instruction immediately following the branch (delay slot) regardless of branch outcome, reducing stall penalty. The compiler must schedule a useful or harmless instruction in the delay slot—ideally independent and executable before the branch decision—or a no-op if none is available. This requires analyzing control flow paths and instruction dependencies to avoid incorrect execution.
   **External example:** Delayed branching is used in classic MIPS processors where the compiler arranges instructions to minimize branch penalties (Hennessy & Patterson, Appendix B: https://csapp.cs.cmu.edu/public/waside/waside-ch3.pdf).

10. **Q:** What adjustments to the pipeline and control logic allow branches to be resolved by the end of the instruction decode stage rather than execution or memory stages?
    **A:** Moving branch target address calculation and condition evaluation to the ID stage requires a separate adder to compute branch targets early and performing the zero or comparison test during ID. The PC multiplexer selects between the incremented PC or branch target address at the end of IF stage, based on the result in EX/MEM or ID/EX. This reduces branch penalty by enabling earlier branch direction determination and PC update.
    **External example:** Early branch resolution techniques are implemented in modern RISC pipelines, such as the MIPS R4000, to reduce stalls (Patel et al., "Branch Prediction Strategies and Pipelines" IEEE Micro: https://ieeexplore.ieee.org/document/214680).
