- **Julia**
  - **G.1 Types**
    - **G.1.1 Booleans**
      - Bool type includes true and false values and supports standard Boolean operators like not, and, or.  
      - Variables can be assigned these Boolean values, including Unicode variable names.  
      - The Julia console uses `#` for comments and semicolons to suppress output.  
      - Further reading: [Julia Booleans](https://docs.julialang.org/en/v1/base/base/#Booleans)
    - **G.1.2 Numbers**
      - Supports Int64 and Float64 as standard numeric types, along with typical arithmetic and comparison operations.  
      - Division of integers produces Float64 results and shorthand assignment operators like `+=` are supported.  
      - Unicode symbols for comparisons such as ≥ (`\ge[tab]`) and ≤ (`\le[tab]`) are valid syntax.  
      - Further reading: [Julia Numbers](https://docs.julialang.org/en/v1/manual/types/#Numbers)  
    - **G.1.3 Strings**
      - Strings are arrays of characters constructed with double quotes.  
      - Primarily used for error reporting in this context.  
      - Further reading: [Julia Strings](https://docs.julialang.org/en/v1/manual/strings/)  
    - **G.1.4 Vectors**
      - One-dimensional arrays created with square brackets or constructors like `ones()`, `zeros()`, and `rand()`.  
      - Supports indexing starting from 1, slicing using ranges, and array comprehensions.  
      - Functions with exclamation marks (e.g., `push!`, `pop!`) mutate arrays in place.  
      - Supports vector arithmetic, broadcasting, and linear algebra functions such as dot product.  
      - Further reading: [Julia Arrays](https://docs.julialang.org/en/v1/manual/arrays/)  
    - **G.1.5 Matrices**
      - Two-dimensional arrays constructed with spaces and semicolons to separate rows and columns.  
      - Supports indexing, slicing, special matrices creation (identity, diagonal), and matrix operations like transpose and inversion.  
      - Elementwise functions and concatenations are demonstrated.  
      - Further reading: [Julia Matrices](https://docs.julialang.org/en/v1/manual/arrays/#Two-Dimensional-Arrays)  
    - **G.1.6 Tuples**
      - Ordered fixed-size collections possibly of mixed types that cannot be mutated.  
      - Indexed similarly to arrays with 1-based indexing, supports unpacking into separate variables.  
      - Further reading: [Julia Tuples](https://docs.julialang.org/en/v1/manual/types/#Tuples)  
    - **G.1.7 Named Tuples**
      - Tuples with named fields accessible by dot notation.  
      - Support destructuring into variables using tuple unpacking.  
      - Further reading: [Julia Named Tuples](https://docs.julialang.org/en/v1/manual/tuples/#Named-Tuples)  
    - **G.1.8 Dictionaries**
      - Collections of key-value pairs created using `Dict()`, with key-value assignment via `=>`.  
      - Supports indexing by key and functions for checking key existence.  
      - Further reading: [Julia Dictionaries](https://docs.julialang.org/en/v1/manual/collections/#Dictionaries)  
    - **G.1.9 Composite Types**
      - Composite types defined with `struct`, are immutable by default but can be mutable using `mutable struct`.  
      - Fields can be optionally type-annotated to enhance performance via compiler optimizations.  
      - Instances are constructed by passing field values in parentheses.  
      - Further reading: [Julia Composite Types](https://docs.julialang.org/en/v1/manual/types/#Composite-Types)  
    - **G.1.10 Abstract Types**
      - Abstract types define type hierarchies and cannot be instantiated directly.  
      - Concrete types are subtypes of abstract types, with `Any` at the top of the hierarchy.  
      - Functions `supertype` and `subtypes` explore this hierarchy.  
      - Users can define their own abstract types and subtypes.  
      - Further reading: [Julia Type Hierarchy](https://docs.julialang.org/en/v1/manual/types/#Type-Hierarchy)  
    - **G.1.11 Parametric Types**
      - Types parameterized by one or more type parameters.  
      - Example includes the `Dict` type parameterized by key and value types.  
      - Allows explicit type declaration though Julia can also infer parameters automatically.  
      - Further reading: [Julia Parametric Types](https://docs.julialang.org/en/v1/manual/types/#Parametric-Types)  
  - **G.2 Functions**
    - **G.2.1 Named Functions**
      - Functions are defined with `function` keyword or compact assignment syntax.  
      - Functions map tuples of arguments to a return value.  
      - Further reading: [Julia Functions](https://docs.julialang.org/en/v1/manual/functions/)  
    - **G.2.2 Anonymous Functions**
      - Functions without names created using the arrow notation `x -> expression`.  
      - Can be assigned to variables or passed as arguments to apply functions.  
      - Further reading: [Julia Anonymous Functions](https://docs.julialang.org/en/v1/manual/functions/#Anonymous-Functions)  
    - **G.2.3 Callable Objects**
      - Types can be made callable by defining methods for `(x::Type)()` and `(x::Type)(y)`.  
      - Allows instances to be invoked like functions with zero or more arguments.  
      - Further reading: [Julia Callable Objects](https://docs.julialang.org/en/v1/manual/types/#Callables)  
    - **G.2.4 Optional Arguments**
      - Default argument values can be specified to make parameters optional.  
      - Allows calls with fewer arguments using default values.  
      - Further reading: [Julia Optional Arguments](https://docs.julialang.org/en/v1/manual/functions/#Optional-Arguments)  
    - **G.2.5 Keyword Arguments**
      - Arguments named in calls enabled via semicolon syntax in function definitions.  
      - Allows optional specification and default values for keyword parameters.  
      - Further reading: [Julia Keyword Arguments](https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments)  
    - **G.2.6 Function Overloading**
      - Specialized methods defined for functions based on argument types using `::` annotations.  
      - Julia dispatches the most specific applicable method when calling the function.  
      - Further reading: [Julia Multiple Dispatch](https://docs.julialang.org/en/v1/manual/methods/)  
    - **G.2.7 Splatting**
      - The `...` operator expands tuples or arrays into function arguments.  
      - Useful for passing collections as multiple separate parameters.  
      - Further reading: [Julia Splatting](https://docs.julialang.org/en/v1/manual/functions/#Varargs-and-Variable-Number-of-Arguments)  
  - **G.3 Control Flow**
    - **G.3.1 Conditional Evaluation**
      - Uses `if`, `elseif`, and `else` blocks to conditionally execute code based on Boolean expressions.  
      - Includes ternary operator syntax using `condition ? expr1 : expr2`.  
      - Further reading: [Julia Conditionals](https://docs.julialang.org/en/v1/manual/control-flow/#Conditional-Expressions)  
    - **G.3.2 Loops**
      - `while` loops repeat execution until a condition is false, demonstrated with array summation.  
      - `for` loops iterate over ranges or collections without modifying the sequence.  
      - Variations include using `in` or `∈` as iteration keywords.  
      - Further reading: [Julia Loops](https://docs.julialang.org/en/v1/manual/control-flow/#Loops)  
    - **G.3.3 Iterators**
      - Provide mechanisms for looping over collections, such as `enumerate`, `eachindex`, `zip`, and `subsets` from `IterTools`.  
      - Support Cartesian products with `Base.Iterators.product`.  
      - Further reading: [Julia Iterators](https://docs.julialang.org/en/v1/manual/iteration/#Iteration)  
  - **G.4 Packages**
    - **G.4.1 NamedTupleTools.jl**
      - Provides utilities to construct, merge, select, or delete fields from named tuples.  
      - Functions like `namedtuple`, `merge`, `select`, and `delete` facilitate tuple manipulation.  
      - Further reading: [NamedTupleTools.jl](https://github.com/JuliaTuple/NamedTupleTools.jl)  
    - **G.4.2 LightGraphs.jl**
      - Enables graph creation and modification with `SimpleDiGraph` and edge operations (`add_edge!`, `rem_edge!`).  
      - Supports querying node count and neighbor lists.  
      - Further reading: [LightGraphs.jl](https://juliagraphs.org/LightGraphs.jl/stable/)  
    - **G.4.3 Distributions.jl**
      - Supports creation, sampling, and fitting of probability distributions like Normal, MvNormal, and Dirichlet.  
      - Allows random sampling, data generation, and parameter estimation.  
      - Further reading: [Distributions.jl](https://github.com/JuliaStats/Distributions.jl)  
    - **G.4.4 JuMP.jl**
      - Facilitates optimization modeling using solver backends such as GLPK.  
      - Provides macros for variable declaration, objectives, and constraints.  
      - Supports optimization and retrieval of solution values.  
      - Further reading: [JuMP.jl](https://jump.dev/JuMP.jl/stable/)
