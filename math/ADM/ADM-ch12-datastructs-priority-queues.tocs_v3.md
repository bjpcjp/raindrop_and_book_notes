![ADM-ch12-datastructs-priority-queues](ADM-ch12-datastructs-priority-queues.best.png)

- **12.2 Priority Queues**
  - **Input description**
    - The input consists of a set of records with numerically or otherwise totally-ordered keys.
  - **Problem description**
    - The problem requires building and maintaining a data structure for quick access to the smallest or largest key in the set.
  - **Discussion**
    - Priority queues retrieve items based on highest priority rather than insertion time or key match.
    - If no insertions follow the initial query, sorting records by priority suffices without a priority queue.
    - Real priority queues are necessary when mixing insertions, deletions, and queries.
    - The discussion highlights key questions to select an appropriate priority queue type.
  - **Priority queue implementations**
    - **Sorted array or list**
      - Efficient for identifying and deleting the smallest element by decrementing the top index.
      - Insertions are slow due to maintaining total order.
      - Suitable only when few insertions occur.
    - **Binary heaps**
      - Support insertion and extract-min in O(lg n) time.
      - Maintain an implicit binary tree in an array ensuring the root key is smallest in the subtree.
      - Require a known upper bound on the number of items due to fixed array size.
      - Dynamic arrays can help mitigate size constraints.
    - **Bounded height priority queue**
      - Use an array of buckets when key values are integers in a limited range.
      - Achieve constant time insertion and find-min operations within the bounded range.
      - Useful for sorting graph vertices by degree and other small discrete key ranges.
    - **Binary search trees**
      - Min and max elements found by tracing leftmost or rightmost leaves.
      - Suitable when dictionary operations or unbounded key ranges occur without known maximum size.
    - **Fibonacci and pairing heaps**
      - Designed to optimize decrease-key operations.
      - Decrease-key in constant amortized time; extract-min and delete in O(lg n).
      - Fibonacci heaps have implementation complexity and high constant factors.
      - Pairing heaps offer similar bounds with less overhead.
  - **Implementations**
    - Modern languages provide efficient priority queue libraries, e.g., C++ STL with push, top, and pop.
    - LEDA offers various priority queues including Fibonacci and pairing heaps.
    - Java provides PriorityQueue in java.util and JDSL as an alternative.
    - Sandersâ€™s sequence heap is experimentally twice as fast as a well-implemented binary heap.
    - Further details and guides are available in [STL documentation](http://www.sgi.com/tech/stl/) and referenced studies.
  - **Notes**
    - The Handbook of Data Structures and Applications surveys priority queue aspects comprehensively.
    - Double-ended priority queues enable simultaneous find-min and find-max operations.
    - Bounded-height priority queues perform well in practice but lack worst-case guarantees under arbitrary operations.
    - von Emde Boas priority queues achieve O(lg lg n) operations within bounded key universes.
    - Fibonacci heaps support faster classical algorithms but can be complex; pairing heaps are a practical alternative.
  - **Related Problems**
    - Priority queues relate closely to dictionaries, sorting, and shortest path problems.
