![ADM-ch09-approximation-algos](ADM-ch09-approximation-algos.best.png)

- **Intractable Problems and Approximation Algorithms**
  - **9.1 Problems and Reductions**
    - Reductions show equivalence between problems and preserve answer correctness.
    - A reduction translates an instance of one problem into another to leverage known algorithms or prove hardness.
    - Decision problems, with yes/no answers, are favored for reductions to simplify analysis.
    - Further reading: [The Algorithm Design Manual](https://doi.org/10.1007/978-1-84800-070-4)
  - **9.2 Reductions for Algorithms**
    - Reductions can be used to create efficient algorithms by transforming problems into known solvable ones.
    - Examples include closest pair reduced to sorting, longest increasing subsequence reduced to edit distance, least common multiple reduced to gcd, and convex hull reduced to sorting.
    - Complexity implications flow both ways: if the target problem is solved efficiently, the original can be solved efficiently as well.
  - **9.3 Elementary Hardness Reductions**
    - Problems like Hamiltonian cycle, vertex cover, independent set, and clique are shown hard through reductions.
    - Hardness is established by chaining reductions from a known hard problem to others.
    - Example: Hamiltonian cycle reduces to traveling salesman decision problem with appropriate weight assignments.
  - **9.4 Satisfiability**
    - The satisfiability (SAT) problem asks if a Boolean formula has a truth assignment satisfying all clauses.
    - SAT is widely accepted as a certifiably hard problem with no known polynomial-time algorithm.
    - 3-SAT, where clauses contain exactly three literals, is NP-complete and serves as a common starting point for reductions.
  - **9.5 Creative Reductions**
    - Reductions from 3-SAT to problems like Integer Programming and Vertex Cover involve creating precise "gadgets" to preserve problem structure.
    - Integer Programming hardness is shown by mapping Boolean variables and clauses into integer variables and constraints.
    - Vertex Cover hardness is shown by translating variables and clauses into graph vertices and edges forming gadgets ensuring cover size encodes satisfiability.
  - **9.6 The Art of Proving Hardness**
    - Effective hardness proofs use restricted source problems and generalized target problems for cleaner reductions.
    - Choosing well-understood NP-complete problems like 3-SAT, vertex cover, integer partition, and Hamiltonian path facilitates proofs.
    - Emphasize amplifying penalties for undesired solutions and building gadget constructions to enforce constraints.
    - When stuck on hardness, consider searching for alternative polynomial algorithms.
  - **9.7 War Story: Hard Against the Clock**
    - Illustrates doing a reduction on demand from a random NP-complete problem.
    - Shows mapping 3-SAT clauses into a program language for the inequivalence of programs problem.
    - Demonstrates how expressive reductions require constructing a program that evaluates satisfiability.
  - **9.8 War Story: And Then I Failed**
    - A failure narrative attempting to reduce vertex cover to uniconnected subgraph problem.
    - Success is eventually achieved by splitting undirected edges into gadgets and adding a sink node.
    - Highlights the importance of creative transformations and persistence in proving NP-hardness.
  - **9.9 P vs. NP**
    - Discusses the distinction between problems verifiable in polynomial time (NP) and those solvable in polynomial time (P).
    - The open question of whether P=NP concerns if solutions can be found as quickly as they are verified.
    - SAT is the foundational NP-complete problem; Cookâ€™s theorem proves that all NP problems reduce to SAT.
    - NP-hard problems are at least as hard as NP-complete problems; some problems outside NP exist like chess.
    - Further reading: [Clay Mathematics Institute - P vs NP](https://www.claymath.org/millennium-problems/p-vs-np-problem)
  - **9.10 Dealing with NP-complete Problems**
    - NP-complete problems still can be approached using average-case fast algorithms, heuristics, or approximation algorithms.
    - Approximation algorithms provide guaranteed bounds on solution quality, often simple and fast.
    - Vertex cover can be approximated within a factor of two using a simple edge-picking heuristic.
    - Euclidean TSP (obeying triangle inequality) can be approximated within a factor of two using minimum spanning trees and shortcutting.
    - Maximum directed acyclic subgraph can be approximated within factor one-half by choosing a vertex ordering and selecting edges accordingly.
    - Set cover admits a logarithmic approximation factor with the greedy heuristic selecting subsets with maximum uncovered elements.
    - Further reading: [Approximation Algorithms - Vijay Vazirani](https://doi.org/10.1007/978-3-642-03162-7)
