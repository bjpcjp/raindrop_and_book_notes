[Representative image](ADM-ch15-graphs-topological-sort.best.png)

- **Topological Sorting**
  - **Input description**
    - The input is a directed acyclic graph (DAG) G = (V, E), also known as a partial order or poset.
    - The graph structure defines precedence constraints among tasks or items.
  - **Problem description**
    - The goal is to find a linear ordering of vertices such that for each edge (i, j), vertex i precedes vertex j.
    - This ordering is known as a topological sort or linear extension.
  - **Discussion**
    - Topological sorting plays a fundamental role in algorithms on DAGs, analogous to DFS in general graphs.
    - It is useful for scheduling tasks respecting precedence constraints represented by edges.
    - The three important facts are: only DAGs can be sorted topologically, every DAG can be sorted, and multiple valid orderings often exist.
  - **Algorithms**
    - The simplest linear-time algorithm repeatedly identifies source vertices (in-degree zero), removes their outgoing edges, and continues until all vertices are processed.
    - An alternative method orders vertices by decreasing DFS finishing time, yielding a valid topological order.
    - Both methods run in O(n + m) time, where n is vertices and m is edges.
  - **Special considerations**
    - Generating all linear extensions is computationally hard and often requires backtracking, which enumerates all valid orderings by iteratively choosing source vertices.
    - Sampling random linear extensions can be done by starting from one extension and randomly swapping pairs if the order remains valid.
    - For graphs that are not acyclic, the feedback vertex set or arc set problems aim to remove minimal sets to eliminate cycles, though both are NP-complete.
    - Heuristics involve deleting offending vertices or edges to restore acyclicity, but may remove more than necessary.
  - **Implementations**
    - Many graph libraries include topological sorting, such as the Boost Graph Library and LEDA for C++, and JDSL and JGraphT for Java.
    - The Combinatorial Object Server provides programs for generating and counting linear extensions.
    - The bookâ€™s associated C library offers implementations of topological sorting and other graph algorithms.
  - **Notes**
    - Counting linear extensions is #P-complete, indicating high computational complexity.
    - Efficient algorithms exist for generating linear extensions with constant amortized time or sampling uniformly at random with polynomial expected time.
    - Key references include [CLRS01](https://mitpress.mit.edu/books/introduction-algorithms), Brightwell and Winkler [BW91], and Pruesse and Ruskey [PR86].
  - **Related problems**
    - Directly related problems include sorting and feedback edge/vertex set problems for cycle elimination.
