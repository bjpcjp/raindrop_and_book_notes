![ADM-ch13-knapsack-problem](ADM-ch13-knapsack-problem.best.png)

- **Knapsack Problem**
  - **Input description**
    - The problem involves a set of items S = {1, ..., n}, each with a size si and a value vi, and a knapsack capacity C.
    - The goal is to find a subset of items maximizing total value without exceeding the capacity C.
  - **Problem description**
    - The knapsack problem is a resource allocation challenge with financial constraints.
    - It is commonly formulated as a 0/1 knapsack problem where items are either fully included or excluded.
    - Greedy algorithms work only if subdivision of items is allowed, otherwise the problem is hard.
  - **Discussion**
    - The 0/1 constraint makes the problem computationally difficult compared to fractional knapsack.
    - The problem models scenarios such as selecting items within a fixed budget.
  - **Issues in selecting algorithms**
    - **Uniform cost/value or size**
      - If all items have the same value, maximize the number by sorting by ascending size.
      - If all items have the same size but different costs, sort and take the cheapest first.
      - These special cases are simpler to solve optimally.
    - **Same price per pound**
      - When each item has the same value-to-weight ratio, the problem reduces to minimizing empty space.
      - This case is NP-complete and closely related to integer partition and subset sum problems.
      - The integer partition problem involves dividing items into two subsets of equal sum.
    - **Small integer sizes**
      - When item sizes and capacity are small integers, dynamic programming can solve the problem in O(nC) time.
      - This approach is efficient for capacities up to around 1,000 but less practical for very large capacities.
    - **Multiple knapsacks**
      - Multiple knapsack problems are better approached as bin-packing problems.
      - Specialized algorithms for multiple knapsacks are referenced in later sections.
  - **Dynamic programming algorithm**
    - Uses a two-dimensional array C[i, S'] indicating whether a subset sums to i.
    - Updates the array by including or excluding each item iteratively.
    - The maximum realizable sum is found by the highest true index in the array.
    - The algorithm can be extended to record values for optimization.
  - **Exact and heuristic solutions**
    - Integer programming can model the 0/1 knapsack with xi binary variables for item inclusion.
    - Greedy heuristics select items based on their price per pound ratio.
    - Scaling heuristics reduce problem size by scaling and rounding items' sizes.
  - **Implementations**
    - Martello and Toth provide Fortran implementations and a reference book.
    - David Pisinger maintains C-language codes for knapsack and related problems.
    - ACM Algorithm 632 supports multiple knapsacks in Fortran.
  - **Notes and references**
    - Keller, Pferschy, and Pisinger offer the most current references on knapsack problems.
    - Martello and Toth’s surveys are standard references for theoretical and experimental results.
    - Polynomial-time approximation schemes present tradeoffs between run-time and approximation quality.
    - Merkle and Hellman’s encryption scheme was based on knapsack problem hardness.
    - Further reading includes [Martello and Toth’s book](http://www.or.deis.unibo.it/kp.html), [David Pisinger’s codes](http://www.diku.dk/~pisinger/codes.html), and survey articles like [Keller et al. 2004].
