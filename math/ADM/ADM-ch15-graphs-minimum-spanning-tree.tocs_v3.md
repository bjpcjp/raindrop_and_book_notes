[Representative image](ADM-ch15-graphs-minimum-spanning-tree.best.png)

- **15.3 Minimum Spanning Tree**
  - **Problem Description**
    - The minimum spanning tree (MST) is the subset of edges with minimum total weight that connects all vertices in a graph without forming cycles.
    - MST is crucial for network design problems, such as minimizing wiring in telephone networks.
    - It identifies clusters by deleting long edges to form connected components.
    - MST algorithms can approximate solutions to complex problems like Steiner tree and traveling salesman.
    - MST also demonstrates that greedy algorithms can produce optimal solutions.
  - **Classical MST Algorithms**
    - Three key algorithms for MST are Kruskal’s, Prim’s, and Boruvka’s algorithms.
    - Kruskal’s algorithm sorts edges and adds the smallest edge that connects distinct components, running in O(m log m) time using union-find.
    - Prim’s algorithm grows a tree from an arbitrary vertex by adding the smallest edge that connects the tree to fringe vertices, running in O(n²) or O(m + n log n) with advanced structures.
    - Boruvka’s algorithm repeatedly adds the smallest edge connected to each tree in the forest, halving the number of trees each iteration for an O(m log n) runtime.
  - **Practical Considerations for MST**
    - If all graph edges have equal weight, any spanning tree is minimum and can be found using BFS or DFS.
    - Prim’s algorithm is faster for dense graphs; Kruskal’s is better for sparse graphs; advanced data structures make Prim’s algorithm practical for both.
    - For geometric problems with points in the plane, constructing the Delaunay triangulation allows MST computation in O(n log n) time rather than O(n²).
    - Finding a spanning tree minimizing maximum vertex degree is NP-complete but approximation algorithms exist within one degree of optimal.
  - **Implementations and Libraries**
    - Implementations of Prim’s and Kruskal’s algorithms exist in various graph libraries, including Boost Graph Library, LEDA, and JDSL.
    - Empirical studies suggest Prim’s algorithm with appropriate priority queues is generally fastest.
    - Combinatorica provides Mathematica implementations for MST and spanning tree counting.
    - The author’s preferred C language library contains basic graph algorithms, including MST.
  - **Historical and Theoretical Notes**
    - MST problem dates back to Boruvka’s algorithm in 1926, while Prim’s and Kruskal’s appeared in the mid-1950s.
    - Optimal MST algorithms utilize Fibonacci or pairing heaps, with pairing heaps offering lower overhead.
    - Combining Boruvka’s with Prim’s yields an O(m log log n) algorithm.
    - Advanced algorithms achieve near-linear or linear time MST computations, such as Karger, Klein, and Tarjan’s randomized linear-time algorithm.
    - MST is connected to matroid theory, allowing greedy algorithms to find maximum weighted independent sets.
    - Dynamic graph algorithms maintain MSTs efficiently under edge insertions or deletions in polylogarithmic amortized time.
    - Spanner networks balance MST total weight and shortest path approximation between vertices.
    - References for further study include [Boost Graph Library](http://www.boost.org/libs/graph/doc), [Combinatorica](https://www.wolfram.com/combinatorica/), and [Narasimhan and Smid (2007)](https://www.springer.com/gp/book/9783642029843).
