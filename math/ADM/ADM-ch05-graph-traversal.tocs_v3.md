![ADM-ch05-graph-traversal](ADM-ch05-graph-traversal.best.png)

- **Graph Traversal**
  - **Flavors of Graphs**
    - Graphs distinguish between undirected and directed edges based on edge symmetry.  
    - Weighted graphs assign numerical values to edges or vertices, influencing shortest path calculations.  
    - Simple graphs exclude self-loops and multiple identical edges; sparse graphs have fewer edges relative to potential connections.  
    - Additional properties include cyclicity, embedding in geometric space, implicit versus explicit representation, and labeling of vertices.  
    - For further depth, consult [The Algorithm Design Manual](https://doi.org/10.1007/978-1-84800-070-4).  
  - **The Friendship Graph**
    - Models social relationships as graphs with vertices representing people and edges representing friendships.  
    - Typically undirected, simple, and unlabeled graphs, often sparse due to natural social limits.  
    - Can be embedded with geographic information or implicitly stored in social networks.  
    - Illustrates importance of proper graph modeling for real-world applications.  
  - **Data Structures for Graphs**
    - Two main representations: adjacency matrices and adjacency lists.  
    - Adjacency matrices enable constant-time edge access but use O(n²) space, impractical for large sparse graphs.  
    - Adjacency lists require O(n + m) space and are preferred for most applications due to efficiency in traversal and storage.  
    - Choosing correct data structures impacts algorithmic performance significantly; see comparative advantages in Figure 5.5.  
  - **War Stories**
    - Combinatorica’s initial use of adjacency matrices created performance bottlenecks addressed by switching to adjacency lists.  
    - The importance of algorithmic asymptotics becomes clear as hardware improves and graph sizes grow.  
    - Efficient graph construction requires appropriately designed data structures; naïve methods can cause quadratic time complexity instead of linear.  
  - **Traversing a Graph**
    - Graph traversal systematically visits all vertices and edges using vertex state flags: undiscovered, discovered, processed.  
    - Traversals prevent revisiting to guarantee completion without cycles.  
    - Properly implemented traversals have O(n + m) time complexity where n is vertices and m is edges.  
  - **Breadth-First Search**
    - Explores vertices level by level using a FIFO queue, creating a shortest-path tree in unweighted graphs.  
    - Supports reconstruction of shortest paths using parent pointers.  
    - Can be customized by processing vertices and edges early or late during traversal.  
    - Used in algorithms for connected components and bipartite (two-color) graph checking.  
    - See [BFS notion and applications](https://doi.org/10.1007/978-1-84800-070-4#chapter-5).  
  - **Applications of Breadth-First Search**
    - Identifies connected components by performing BFS from undiscovered vertices iteratively.  
    - Detects bipartite graphs via a two-coloring scheme assigning opposite colors to adjacent vertices and checking for color conflicts.  
  - **Depth-First Search**
    - Explores as far as possible along a branch before backtracking, using a LIFO stack implemented naturally with recursion.  
    - Maintains entry and exit times for vertices to deduce ancestor-descendant relationships.  
    - Partitions undirected graph edges into tree edges and back edges.  
  - **Applications of Depth-First Search**
    - Detects cycles in undirected graphs by identifying back edges.  
    - Finds articulation vertices (cut-nodes) that disconnect the graph upon removal by tracking earliest reachable ancestors and tree outdegree.  
    - Differentiates root, bridge, and parent cut-nodes based on DFS tree structure and back edges.  
  - **Depth-First Search on Directed Graphs**
    - Classifies edges into tree, back, forward, and cross edges, enabling nuanced processing.  
    - Supports topological sorting on Directed Acyclic Graphs (DAGs) by labeling vertices in reverse finish order—useful for scheduling and path computations.  
    - Finds strongly connected components by tracking low values representing the earliest reachable vertex in a component and maintaining an active stack of vertices.  
    - See [Topological sorting and strongly connected components](https://doi.org/10.1007/978-1-84800-070-4#chapter-15).  
  - **Exercises**
    - Problems span graph traversal simulation, algorithm design, directed graphs, articulation vertices, and programming challenges.  
    - Exercises include BFS/DFS vertex order determination, shortest path counting, dual graph construction, vertex cover and independent set algorithms on trees, and cycle detection.  
    - Programming challenges available at [Programming Challenges](http://www.programming-challenges.com) and UVA Online Judge.
